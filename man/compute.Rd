% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute-collect.r, R/tbl-sql.r
\name{compute}
\alias{compute}
\alias{collect}
\alias{collapse}
\alias{compute.tbl_sql}
\title{Force computation of a database query}
\usage{
compute(x, name = random_table_name(), ...)

collect(x, ...)

collapse(x, ...)

\method{compute}{tbl_sql}(x, name = random_table_name(), temporary = TRUE,
  unique_indexes = list(), indexes = list(), ...)
}
\arguments{
\item{x}{A tbl}

\item{name}{Name of temporary table on database.}

\item{...}{Other arguments passed on to methods}

\item{temporary}{if \code{TRUE}, will create a temporary table that is
local to this connection and will be automatically deleted when the
connection expires}

\item{unique_indexes}{a list of character vectors. Each element of the list
will create a new unique index over the specified column(s). Duplicate rows
will result in failure.}

\item{indexes}{a list of character vectors. Each element of the list
will create a new index.}
}
\description{
\code{compute()} stores results in a remote temporary table.
\code{collect()} retrieves data into a local tibble.
\code{collapse()} is slightly different: it doesn't force computation, but
instead forces generation of the SQL query. This is sometimes needed to work
around bugs in dplyr's SQL generation.
}
\details{
All functions preserve grouping and ordering.
}
\examples{
if (require("RSQLite")) {
  mtcars2 <- src_memdb() \%>\%
    copy_to(mtcars, name = "mtcars2-cc", overwrite = TRUE)

  remote <- mtcars2 \%>\%
    filter(cyl == 8) \%>\%
    select(mpg:drat)

  # Compute query and save in remote table
  compute(remote)

  # Compute query bring back to this session
  collect(remote)

  # Creates a fresh query based on the generated SQL
  collapse(remote)
}
}
\seealso{
\code{\link[=copy_to]{copy_to()}}, the opposite of \code{collect()}: it takes a local data
frame and uploads it to the remote source.
}
