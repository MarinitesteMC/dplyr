% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colwise-mutate.R
\name{summarise_all}
\alias{summarise_all}
\alias{summarise_each_q}
\alias{mutate_each_q}
\alias{mutate_all}
\alias{transmute_all}
\alias{summarise_if}
\alias{mutate_if}
\alias{transmute_if}
\alias{summarise_at}
\alias{mutate_at}
\alias{transmute_at}
\alias{summarize_all}
\alias{summarize_at}
\alias{summarize_if}
\title{Summarise and mutate multiple columns.}
\usage{
summarise_all(.tbl, .funs, ...)

mutate_all(.tbl, .funs, ...)

transmute_all(.tbl, .funs, ...)

summarise_if(.tbl, .predicate, .funs, ...)

mutate_if(.tbl, .predicate, .funs, ...)

transmute_if(.tbl, .predicate, .funs, ...)

summarise_at(.tbl, .vars, .funs, ..., .cols = NULL)

mutate_at(.tbl, .vars, .funs, ..., .cols = NULL)

transmute_at(.tbl, .vars, .funs, ..., .cols = NULL)

summarize_all(.tbl, .funs, ...)

summarize_at(.tbl, .vars, .funs, ..., .cols = NULL)

summarize_if(.tbl, .predicate, .funs, ...)
}
\arguments{
\item{.tbl}{A \code{tbl} object.}

\item{.funs}{List of function calls generated by \code{\link[=funs]{funs()}}, or a
character vector of function names, or simply a function.}

\item{...}{Additional arguments for the function calls in
\code{.funs}. These are evaluated only once.}

\item{.predicate}{A predicate function to be applied to the columns
or a logical vector. The variables for which \code{.predicate} is or
returns \code{TRUE} are selected. This argument is passed to
\code{\link[rlang:as_function]{rlang::as_function()}} and thus supports quosure-style lambda
functions and strings representing function names.}

\item{.vars}{A list of columns generated by \code{\link[=vars]{vars()}},
or a character vector of column names, or a numeric vector of column
positions.}

\item{.cols}{This argument has been renamed to \code{.vars} to fit
dplyr's terminology and is deprecated.}
}
\value{
A data frame. By default, the newly created columns have the shortest
names needed to distinguish the output. To force inclusion of a name,
even when not needed, name the input (see examples for details).
}
\description{
These verbs are \link{scoped} variants of \code{\link[=summarise]{summarise()}}, \code{\link[=mutate]{mutate()}} and
\code{\link[=transmute]{transmute()}}. They apply operations on a selection of variables.
\itemize{
\item \code{summarise_all()}, \code{mutate_all()} and \code{transmute_all()} apply the
functions to all (non-grouping) columns.
\item \code{summarise_at()}, \code{mutate_at()} and \code{transmute_at()} allow you to
select columns using the same name-based \link{select_helpers} just
like with \code{\link[=select]{select()}}.
\item \code{summarise_if}(), \code{mutate_if}() and \code{transmute_if()} operate on
columns for which a predicate returns \code{TRUE}.
\item \code{\link[=summarise_each]{summarise_each()}} and \code{\link[=mutate_each]{mutate_each()}} are older variants that
are now deprecated.
}
}
\examples{
by_species <- iris \%>\% group_by(Species)

# One function
by_species \%>\% summarise_all(n_distinct)
by_species \%>\% summarise_all(mean)

# Use the _at and _if variants for conditional mapping.
by_species \%>\% summarise_if(is.numeric, mean)

# summarise_at() can use select() helpers with the vars() function:
by_species \%>\% summarise_at(vars(Petal.Width), mean)
by_species \%>\% summarise_at(vars(matches("Width")), mean)

# You can also specify columns with column names or column positions:
by_species \%>\% summarise_at(c("Sepal.Width", "Petal.Width"), mean)
by_species \%>\% summarise_at(c(1, 3), mean)

# You can provide additional arguments. Those are evaluated only once:
by_species \%>\% summarise_all(mean, trim = 1)
by_species \%>\% summarise_at(vars(Petal.Width), mean, trim = 1)

# You can provide an expression or multiple functions with the funs() helper.
by_species \%>\% mutate_all(funs(. * 0.4))
by_species \%>\% summarise_all(funs(min, max))
# Note that output variable name must now include function name, in order to
# keep things distinct.

# Function names will be included if .funs has names or whenever multiple
# functions are used.
by_species \%>\% mutate_all(funs("in" = . / 2.54))
by_species \%>\% mutate_all(funs(rg = diff(range(.))))
by_species \%>\% summarise_all(funs(med = median))
by_species \%>\% summarise_all(funs(Q3 = quantile), probs = 0.75)
by_species \%>\% summarise_all(c("min", "max"))

# Two functions, continued
by_species \%>\% summarise_at(vars(Petal.Width, Sepal.Width), funs(min, max))
by_species \%>\% summarise_at(vars(matches("Width")), funs(min, max))


# Unlike mutating verbs, the transmute variants discard original
# variables when the computations have new names:
mutate_if(as_tibble(iris), is.numeric, funs(mean, sd))
transmute_if(as_tibble(iris), is.numeric, funs(mean, sd))
}
\seealso{
\code{\link[=vars]{vars()}}, \code{\link[=funs]{funs()}}
}
